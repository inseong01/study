react
	클라이언트 사이드 렌더링?
	유저 측에서 렌더링
	서버에서 모든 파일을 받아놓음, 브라우저에서 꺼내 씀
	: 초기 접속 느림 -> 서버에서 파일을 받고 브라우저에서 렌더링하는 역할의 과정이 긺

Next
	서버 렌더링
	서버 측에서 js HTML 코드 변환(렌더링)
	js 파일,  브라우저가 화면으로 렌더링
	수화를 통해 TTI 상호작용 가능
	초기렌더링 이후 클라이언트 사이드 렌더링
	FCP (초기 화면) 과정: HTML 받음-> 수화(요청한 JS 번들 받음) -> TTI(상호작용: 화면 보임)

*초기 접속: FCP
*프리패칭: 초기화면 렌더링 이후 지정한 js 파일을 불러오는 기능*

Next 설치
	npx create-next-app@14 section01

Next 구성 파일
- Document.tsx
	페이지 전체 구조 설정: 리액트의 index.html
- app.tsx	
	페이지 공통부분: header

App Router
폴더의 구조 기반으로 페이지 라우팅 제공
	
	페이지 생성
		1. 
		Pages 폴더
			ㄴ (메인 페이지) 실행 파일: index.tsx
			ㄴ (서브 페이지) 실행 파일: "URI 경로명".tsx 
		2. 
		Pages 폴더
			ㄴ (메인 페이지) 실행 파일: index.tsx
			ㄴ [URI 경로명] 폴더 
				ㄴ (서브 메인 페이지) 실행 파일: index.tsx
				ㄴ (서브 페이지) 동적 경로 실행 파일: [id].tsx 

		404 처리
		1.
		Pages 폴더
			ㄴ 파일 생성: 404.tsx

	페이지 이동(네비게이팅)
	: 클라이언트 사이드 렌더링
		Link - 지정한 href로 이동 
		useRouter.push('주소 입력') - 지정한 주소로 이동
		useRouter.back() - 뒤로가기
		useRouter.replace() - 뒤로가기 방지하며 이동

	미리불러오기(프리패칭)
	: 초기화면 렌더링 이후 지정한 js 파일을 불러오는 기능, 빠른 페이지 이동 목적, 빌드 했을 때만 확인가능

		프리패칭 설정
			- 자동
			불러온 페이지에 이동 링그는 프리패칭 됨
			- 사용자 설정
			useEffect 안에 useRouter().prefetch('주소 입력') 추가

			- 해제
			<Link ... prefetch={false}></Link> 

	API Routes
	: api/해당 주소로 이동하면 ts 파일 실행

		api 폴더
			ㄴ 파일 생성: ~.ts
	
	스타일링
		app.tsx에서만 css 파일 import 가능, 스타일링 겹침 방지
		다른 파일에서 css 파일 불러올라면 
			1. ~.module.css 파일명 사용
			2. import style from './~.module.css'
			3. className={style.~} 클래스명 부여
		
	특정부분 레이아웃
		1. 특정 레이아웃 파일 생성
		1. 특정부분이 적용될 컴포넌트 파일에서 컴포넌트 getLayout() 프로퍼티 추가
		2. app.tsx, getLayout() 함수 인자로 컴포넌트 삽입

---------------------------------

Next 사전 렌더링
	페이지마다 렌더링 방식 지정 가능

	1. 서버 사이드 렌더링(SSR)
		요청 들어올 때마다 사전 렌더링 진행(최신 데이터 유지)
		백엔드 서버(요청,반응)가 느리다면 계속 기다려야함(빈 화면)

	2. 정적 사이트 생성(SSG) - 기본값(getStaticProps)
		빌드 타임에 미리 페이지 사전 생성 페이지 생성, 요청 시 렌더링(SSR 단점 보완)
		최신 데이터 반영 어려움, meta 데이터 삽입 힘듦 - 컴포넌트 내에서 비동기 함수 + useEffect 조합

			getStaticPaths
				- paths: [{ params: { id: '1' } }], // 해당 경로 html 파일 미리 생성
				- fallback
					: false, // path 외 경로 접근 시 404.tsx 실행
					: 'blocking', // SSR 방식(빈 화면)
					: true, // SSR + 데이터 없는 풀백 상태 페이지 반환 
					*false를 제외하고 로드되는 페이지는 서버에 저장됨, 다시 접속하면 로딩X

	3. 증분 정적 재생성(ISR)
		revalidate 설정으로 지정한 시간 이후 새로고침 시 데이터 갱신

			On-Demand-ISR
			: 요청 받을 때마다 ISR 작동, res.revalidate(주소)

에러처리 
	1. 'key' is specified more than once, so this usage will be overwritten.
	: 컴포넌트 key와 타입 key 충돌, 타입 안에 key 라는 타입이 있다면 오류 발생 