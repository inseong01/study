react
	클라이언트 사이드 렌더링?
	유저 측에서 렌더링
	서버에서 모든 파일을 받아놓음, 브라우저에서 꺼내 씀
	: 초기 접속 느림 -> 서버에서 파일을 받고 브라우저에서 렌더링하는 역할의 과정이 긺

Next
	서버 렌더링
	서버 측에서 js HTML 코드 변환(렌더링)
	js 파일,  브라우저가 화면으로 렌더링
	수화를 통해 TTI 상호작용 가능
	초기렌더링 이후 클라이언트 사이드 렌더링
	FCP (초기 화면) 과정: HTML 받음-> 수화(요청한 JS 번들 받음) -> TTI(상호작용: 화면 보임)

*초기 접속: FCP
*프리패칭: 초기화면 렌더링 이후 지정한 js 파일을 불러오는 기능*

Next 설치
	npx create-next-app@14 section01

Next 구성 파일
- Document.tsx
	페이지 전체 구조 설정: 리액트의 index.html
- app.tsx	
	페이지 공통부분: header

Page Router
폴더의 구조 기반으로 페이지 라우팅 제공
	
	페이지 생성
		1. 
		Pages 폴더
			ㄴ (메인 페이지) 실행 파일: index.tsx
			ㄴ (서브 페이지) 실행 파일: "URI 경로명".tsx 
		2. 
		Pages 폴더
			ㄴ (메인 페이지) 실행 파일: index.tsx
			ㄴ [URI 경로명] 폴더 
				ㄴ (서브 메인 페이지) 실행 파일: index.tsx
				ㄴ (서브 페이지) 동적 경로 실행 파일: [id].tsx 

		404 처리
		1.
		Pages 폴더
			ㄴ 파일 생성: 404.tsx

	페이지 이동(네비게이팅)
	: 클라이언트 사이드 렌더링
		Link - 지정한 href로 이동 
		useRouter.push('주소 입력') - 지정한 주소로 이동
		useRouter.back() - 뒤로가기
		useRouter.replace() - 뒤로가기 방지하며 이동

	미리불러오기(프리패칭)
	: 초기화면 렌더링 이후 지정한 js 파일을 불러오는 기능, 빠른 페이지 이동 목적, 빌드 했을 때만 확인가능

		프리패칭 설정
			- 자동
			불러온 페이지에 이동 링그는 프리패칭 됨
			- 사용자 설정
			useEffect 안에 useRouter().prefetch('주소 입력') 추가

			- 해제
			<Link ... prefetch={false}></Link> 

	API Routes
	: api/해당 주소로 이동하면 ts 파일 실행

		api 폴더
			ㄴ 파일 생성: ~.ts
	
	스타일링
		app.tsx에서만 css 파일 import 가능, 스타일링 겹침 방지
		다른 파일에서 css 파일 불러올라면 
			1. ~.module.css 파일명 사용
			2. import style from './~.module.css'
			3. className={style.~} 클래스명 부여
		
	특정부분 레이아웃
		1. 특정 레이아웃 파일 생성
		1. 특정부분이 적용될 컴포넌트 파일에서 컴포넌트 getLayout() 프로퍼티 추가
		2. app.tsx, getLayout() 함수 인자로 컴포넌트 삽입

	Next 사전 렌더링
	페이지마다 렌더링 방식 지정 가능

	1. 서버 사이드 렌더링(SSR)
		요청 들어올 때마다 사전 렌더링 진행(최신 데이터 유지)
		백엔드 서버(요청,반응)가 느리다면 계속 기다려야함(빈 화면)

	2. 정적 사이트 생성(SSG) - 기본값(getStaticProps)
		빌드 타임에 미리 페이지 사전 생성 페이지 생성, 요청 시 렌더링(SSR 단점 보완)
		최신 데이터 반영 어려움, meta 데이터 삽입 힘듦 - 컴포넌트 내에서 비동기 함수 + useEffect 조합

			getStaticPaths
				- paths: [{ params: { id: '1' } }], // 해당 경로 html 파일 미리 생성
				- fallback
					: false, // path 외 경로 접근 시 404.tsx 실행
					: 'blocking', // SSR 방식(빈 화면)
					: true, // SSR + 데이터 없는 풀백 상태 페이지 반환 
					*false를 제외하고 로드되는 페이지는 서버에 저장됨, 다시 접속하면 로딩X

	3. 증분 정적 재생성(ISR)
		revalidate 설정으로 지정한 시간 이후 새로고침 시 데이터 갱신

			On-Demand-ISR
			: 요청 받을 때마다 ISR 작동, res.revalidate(주소)

에러처리 
	1. 'key' is specified more than once, so this usage will be overwritten.
	: 컴포넌트 key와 타입 key 충돌, 타입 안에 key 라는 타입이 있다면 오류 발생 

---------------------------------

App Router
폴더의 구조 기반으로 앱 라우팅 제공
page, layout 외 파일명은 ts, js 같은 확장자 형식으로 인식

	구조
		app
		ㄴ page.tsx - '/' 페이지
		ㄴ search
				ㄴ page.tsx - '/search' 페이지

		function({params, searchParams}) // 2개의 주소 받음
		*params: 동적 라우팅 매개변수 객체 모음*
		*searchParams: 쿼리스트링 변수 객체 모음*

	layout
		폴더 내 layout.tsx 생성, 하위 파일까지 적용됨

		특정 컴포넌트만 layout 적용 방법
			라우트 그룹 폴더(소괄호 폴더명) 생성, 폴더 내 파일 모음

			(...) 폴더 - 라우트 그룹 폴더
				ㄴ layout.tsx
				ㄴ ...
			
	server component 
		앱 라우터의 기본 컴포넌트는 서버 컴포넌트 (콘솔로그 터미널에서만 보임)

		리액트 기능을 사용하려면 
			: 'use client' 선언
				ㄴ 왜 지정해야 하는지
					: 클라이언트 컴포넌트만 불러옴, js 번들 크기 줄임

		client component 주의사항
			1. 서버, 클라이언트(수화)에서 각각 실행 (2번 실행됨)
			2. 서버 컴포넌트 import X -> server가 client component로 변환됨
					ㄴ 서버 컴포넌트를 props로 클라이언트에게 넘기면 서버 컴포넌트 유지됨
			3. 서버 컴포넌트에서 직렬화 되지 않은 props는 전달 불가
					ㄴ 예: 함수, 파일핸들, 스레드, 네트워크 소켓
	
	navigating
		js bundle: 클라이언트 컴포넌트 전달
		RSC payload: 서버 컴포넌트 전달

	Page -> App Router 전환
	: 응답 느려짐, 서버 컴포넌트 fetch 응답시간 의심

	fetch 캐싱
	캐시: 복사한 데이터 값을 임시 저장하는 공간
	 - { cache: 'force-cache' }
	 	: 한 번 fetch 된 데이터 캐시에 저장됨, 갱신되지 않음
	 - { cache: 'no-cache' }
	 	: fetch 데이터 캐시에 저장되지 않음, 갱신됨
	- { next: { revalidate: 5 } }
	 	: 5초 동안 캐시 유지, ISR 유사
	- { next: { tag: ['a'] } }
		: 요청 받았을 때까지 캐시유지, On-Demand-ISR 유사

	Request Memoization
	: 한 페이지에서 fetch 데이터 동일한지 비교, 중복 fetch가 있다면 하나의 fetch만 작동
